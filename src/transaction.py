# pylint: disable=too-many-arguments, too-many-positional-arguments, too-many-instance-attributes
"""
The Autonomous Cooperative Consensus Orbit Determination (ACCORD) framework.
Author: Beth Probert
Email: beth.probert@strath.ac.uk

Copyright (C) 2025 Applied Space Technology Laboratory

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""

import hashlib
from datetime import datetime
from dataclasses import dataclass, field

@dataclass
class TransactionMetadata:
    """
    Transaction metadata information to be submitted in the Distributed Ledger.
    """
    timestamp: datetime = field(default_factory=datetime.now)
    consensus_reached: bool = False
    is_confirmed: bool = False
    parent_hashes: list[str] = field(default_factory=list)
    is_rejected: bool = False
    consensus_score: float = 0.0
    dof: int = 0
    cdf: float = 0.0

class Transaction:
    """
    Transaction containing information to be submitted in the Distributed Ledger.
    Consensus needs to be reached on the validity of the information received.
    """

    def __init__(self, sender_address: int, recipient_address: int,
                 sender_private_key: str, tx_data: str,
                 metadata: TransactionMetadata) -> None:

        self.sender_address = sender_address
        self.recipient_address = recipient_address
        self.sender_private_key = sender_private_key
        self.tx_data = tx_data
        self.metadata = metadata

    def __repr__(self) -> str:
        return (f"Transaction(\n"
                f"  sender_address={self.sender_address},\n"
                f"  recipient_address={self.recipient_address},\n"
                f"  timestamp={self.metadata.timestamp},\n"
                f"  tx_data='{self.tx_data}',\n"
                f"  consensus_reached={self.metadata.consensus_reached},\n"
                f"  is_confirmed={self.metadata.is_confirmed},\n"
                f"  is_rejected={self.metadata.is_rejected},\n"
                f"  parent_hashes={self.metadata.parent_hashes},\n"
                f"  hash={self.hash[:10]}...)\n")

    @property
    def hash(self):
        """
        Define hash as a computed property, so it's always based on the current state.
        """
        return self.calculate_hash()

    def calculate_hash(self) -> str:
        """
        Calculates a hash string for a transaction. The hash is generated by encoding all of
        the transaction's unique information, so that ANY change to a transaction results in a new 
        hash, making tampering easier to identify.

        Returns: The has as a string.
        """
        return hashlib.sha256(str(self.sender_address).encode() +
                              str(self.metadata.timestamp).encode() +
                              self.sender_private_key.encode() + self.tx_data.encode() +
                              str(self.recipient_address).encode()
                             ).hexdigest()
