"""
The Autonomous Cooperative Consensus Orbit Determination (ACCORD) framework.
Author: Beth Probert
Email: beth.probert@strath.ac.uk

Copyright (C) 2025 Applied Space Technology Laboratory

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""

import hashlib # TODO - might use a different algorithm? we will see if needed. Start small ffs dont get overwhelmed by the whole ledger
from datetime import datetime

class Transaction():
    """
    Transaction containing information to be submitted in the Distributed Ledger.
    Consensus needs to be reached on the validity of the information received.
    """
    def __init__(self, sender_address, recipient_address, sender_private_key, timestamp, tx_data, consensus_reached: bool = False, is_confirmed: bool = False) -> None:
        self.sender_address: int = sender_address
        self.recipient_address: int = recipient_address
        self.sender_private_key: str = sender_private_key
        self.timestamp: datetime = timestamp
        self.consensus_reached: bool = consensus_reached
        self.is_confirmed: bool = is_confirmed
        # TODO Add cooperative OD information to TLE data json
        # tx_data will include cooperative OD data, so including the ID 
        # and trajectory info for a witnessed satellite as well.
        self.tx_data: str = tx_data
        
        self.parent_hashes: list[str] = []
        self.confirmation_score: float = 0
        self.is_rejected: bool = False

        self.hash = self.calculate_hash()
    
    def __repr__(self) -> str:
        return (f"Transaction(\n"
                f"  sender_address={self.sender_address},\n"
                f"  recipient_address={self.recipient_address},\n"
                f"  timestamp={self.timestamp},\n"
                f"  tx_data='{self.tx_data}',\n"
                f"  consensus_reached={self.consensus_reached},\n"
                f"  is_confirmed={self.is_confirmed},\n"
                f"  is_rejected={self.is_rejected},\n"
                f"  confirmation_score={self.confirmation_score},\n"
                f"  parent_hashes={self.parent_hashes},\n"
                f"  hash={self.hash[:10]}...)\n")
        
    def calculate_hash(self) -> str:
        """
        Calculates a hash string for a transaction. The hash is generated by encoding all of
        the transaction's unique information, so that ANY change to a transaction results in a new 
        hash, making tampering easier to identify.
        """
        return hashlib.sha256(str(self.sender_address).encode() + str(self.timestamp).encode() + 
                              self.sender_private_key.encode() + self.tx_data.encode() + 
                              str(self.recipient_address).encode()
                             ).hexdigest()