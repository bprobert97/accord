@startuml

start

:Define simulation parameters (FilterConfig);
:Set random seed;

:call simulate_truth_and_meas(N, steps, dt, ...);
note right
  - Create initial state vector (x0_stack)
  - Propagate truth for all steps using Keplerian dynamics (rk4_step)
  - Generate stacked noisy measurements (z_hist) for all steps
end note
:truth_hist, z_hist = result;

:Instantiate JointEKF(config, truth_hist);
note right
  - Initialise EKF object
  - Create initial state estimate and covariance (P0)
end note

:Initialise history arrays (x_hist, obs_records);

while (for each simulation step k)
  :joint_ekf.predict();
  note left
    - Propagate state for each satellite (rk4_step)
    - Propagate covariance for each satellite block
      using Van Loan discretization
  end note

  :Get measurement z_k from z_hist[k];

  :joint_ekf.update(z_k, k);
  note right
    - Calculate joint measurement Jacobian H
    - Calculate innovation y
    - Calculate Kalman Gain K
    - Update state x
    - Update covariance P (Joseph form)
    - Log NIS for each observation pair
  end note
  :Store updated state x_hist[k];
  :Append observation records;

endwhile

:Create JointResult object with all histories;

stop

@enduml
